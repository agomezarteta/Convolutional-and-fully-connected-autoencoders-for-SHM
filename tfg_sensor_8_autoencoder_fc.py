# -*- coding: utf-8 -*-
"""TFG SENSOR 8 autoencoder FC

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nGIObSADrwQdtHbPGZSK7DPIFk7W3VLH

#AUTOENCODER PARA DETECTAR ANOMALÍAS EN ESTRUCTURAS

## LIBRERÍAS
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from matplotlib import pyplot as plt
from tensorflow.keras.layers import Conv1D, Conv1DTranspose, Dense, Flatten, Reshape
from tensorflow.keras.models import Sequential
import torch as th
import torch.nn as nn

from sklearn.metrics import mean_squared_error
def rmse(y, yprime):
    return np.sqrt(mean_squared_error(y.detach().numpy(), yprime.detach().numpy()))

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')

! ls
# %cd /content/drive/MyDrive/Colab\ Notebooks/Sensor8
! ls
! pwd

"""##**SENSOR 8**

"""

sensor8_s = pd.read_excel("PROBETA1_BASELINE_VEDIT_sensor8_AUTOENCODER.xlsx")
print(sensor8_s.head())

min_reference_b = sensor8_s.min().min()
max_reference_b = sensor8_s.max().max()
min = min_reference_b
max = max_reference_b

"""## NORMALIZACIÓN DE DATOS

Carga de todos los datos
"""

testS8_pc1_s = pd.read_excel("PROBETA1_PASO_CARGA_1_sensor8_AUTOENCODER.xlsx")
min_reference_1 = testS8_pc1_s.min().min()
max_reference_1 = testS8_pc1_s.max().max()
print(max_reference_1)
print(min_reference_1)
if max_reference_1 > max :
  max = max_reference_1
  min = min_reference_1
print(max)
print(min)

testS8_pc2_s = pd.read_excel("PROBETA1_PASO_CARGA_2_sensor8_AUTOENCODER.xlsx")
min_reference_2 = testS8_pc2_s.min().min()
max_reference_2 = testS8_pc2_s.max().max()
print(max_reference_2)
print(min_reference_2)
if max_reference_2 > max :
  max = max_reference_2
  min = min_reference_2
print(max)
print(min)

testS8_pc3_s = pd.read_excel("PROBETA1_PASO_CARGA_3_sensor8_AUTOENCODER.xlsx")
min_reference_3 = testS8_pc3_s.min().min()
max_reference_3 = testS8_pc3_s.max().max()
print(max_reference_3)
print(min_reference_3)
if max_reference_3 > max :
  max = max_reference_3
  min = min_reference_3
print(max)
print(min)

testS8_pc4_s = pd.read_excel("PROBETA1_PASO_CARGA_4_sensor8_AUTOENCODER.xlsx")
min_reference_4 = testS8_pc4_s.min().min()
max_reference_4 = testS8_pc4_s.max().max()
print(max_reference_4)
print(min_reference_4)
if max_reference_4 > max :
  max = max_reference_4
  min = min_reference_4

print(max)
print(min)

testS8_pc5_s = pd.read_excel("PROBETA1_PASO_CARGA_5_sensor8_AUTOENCODER.xlsx")
min_reference_5 = testS8_pc5_s.min().min()
max_reference_5 = testS8_pc5_s.max().max()
print(max_reference_5)
print(min_reference_5)
if max_reference_5 > max :
  max = max_reference_5
  min = min_reference_5

print(max)
print(min)

testS8_pc6_s = pd.read_excel("PROBETA1_PASO_CARGA_6_VIGA_ROTA_sensor8_AUTOENCODER.xlsx")
min_reference_6 = testS8_pc6_s.min().min()
max_reference_6 = testS8_pc6_s.max().max()
print(max_reference_6)
print(min_reference_6)
if max_reference_6 > max :
  max = max_reference_6
  min = min_reference_6

print(max)
print(min)

plt.plot(sensor8_s['P_  1'], label = 'Baseline')
plt.plot(testS8_pc1_s['PP1_1'], label = 'Paso de carga 1')
plt.plot(testS8_pc2_s['PP2_1'], label = 'Paso de carga 2')
plt.plot(testS8_pc3_s['PP3_1'], label = 'Paso de carga 3')
plt.plot(testS8_pc4_s['PP4_1'], label = 'Paso de carga 4')
plt.plot(testS8_pc5_s['PP5_1'], label = 'Paso de carga 5')
plt.title('Impedances for Different Load Steps not including the state of rupture')
plt.legend()
plt.show()

sensor8 = (sensor8_s - min) / (max-min)

testS8_pc1_n = (testS8_pc1_s - min) / (max-min)
testS8_pc1_n2 = np.transpose(testS8_pc1_n)
testS8_pc1_n3 = testS8_pc1_n2.values.astype(np.float32)
testS8_pc1 = th.tensor(testS8_pc1_n3)
print(testS8_pc1)
print(testS8_pc1_n2)
print(testS8_pc1.shape)

testS8_pc2_n = (testS8_pc2_s - min) / (max-min)
testS8_pc2_n2 = np.transpose(testS8_pc2_n)
testS8_pc2_n3 = testS8_pc2_n2.values.astype(np.float32)
testS8_pc2 = th.tensor(testS8_pc2_n3)
print(testS8_pc2)
print(testS8_pc2_n2)
print(testS8_pc2.shape)

testS8_pc3_n = (testS8_pc3_s - min) / (max-min)
testS8_pc3_n2 = np.transpose(testS8_pc3_n)
testS8_pc3_n3 = testS8_pc3_n2.values.astype(np.float32)
testS8_pc3 = th.tensor(testS8_pc3_n3)
print(testS8_pc3)
print(testS8_pc3_n2)
print(testS8_pc3.shape)

testS8_pc4_n = (testS8_pc4_s - min) / (max-min)
testS8_pc4_n2 = np.transpose(testS8_pc4_n)
testS8_pc4_n3 = testS8_pc4_n2.values.astype(np.float32)
testS8_pc4 = th.tensor(testS8_pc4_n3)
print(testS8_pc4)
print(testS8_pc4_n2)
print(testS8_pc4.shape)

testS8_pc5_n = (testS8_pc5_s - min) / (max-min)
testS8_pc5_n2 = np.transpose(testS8_pc5_n)
testS8_pc5_n3 = testS8_pc5_n2.values.astype(np.float32)
testS8_pc5 = th.tensor(testS8_pc5_n3)
print(testS8_pc5)
print(testS8_pc5_n2)
print(testS8_pc5.shape)

testS8_pc6_n = (testS8_pc6_s - min) / (max-min)
testS8_pc6_n2 = np.transpose(testS8_pc6_n)
testS8_pc6_n3 = testS8_pc6_n2.values.astype(np.float32)
testS8_pc6 = th.tensor(testS8_pc6_n3)
print(testS8_pc6)
print(testS8_pc6_n2)
print(testS8_pc6.shape)

plt.plot(sensor8['P_  1'], label = 'Baseline')
plt.plot(testS8_pc1_n['PP1_1'], label = 'Paso de carga 1')
plt.plot(testS8_pc2_n['PP2_1'], label = 'Paso de carga 2')
plt.plot(testS8_pc3_n['PP3_1'], label = 'Paso de carga 3')
plt.plot(testS8_pc4_n['PP4_1'], label = 'Paso de carga 4')
plt.plot(testS8_pc5_n['PP5_1'], label = 'Paso de carga 5')
plt.title('Impedances normalized for Different Load Steps not including the state of rupture')
plt.legend()
plt.show()

"""## PREPARACIÓN DATOS DE ENTRENAMIENTO"""

sensor8_t = np.transpose(sensor8)
print(sensor8_t.head())

"""## CREACIÓN DE LOS GRUPOS APRENDIZAJE Y TEST"""

from sklearn.model_selection import train_test_split
trainS8,testS8 = train_test_split(sensor8_t,train_size=0.75,random_state=111)
print(trainS8)
print(testS8)

"""## RED NEURONAL

"""

class Autoencoder(nn.Module):
    def __init__(self):
        super(Autoencoder, self).__init__()
        # The encoding layers
        self.encoder = nn.Sequential(
            nn.Linear(7201, 800),
            nn.PReLU(),
            nn.Linear(800, 50),
            nn.PReLU(),
            nn.Linear(50, 8),
            nn.PReLU(),
        )
        # The decoding layers
        self.decoder = nn.Sequential(
            nn.Linear(8, 50),
            nn.PReLU(),
            nn.Linear(50, 800),
            nn.PReLU(),
            nn.Linear(800, 7201),
            nn.PReLU()
        )

    def forward(self, x):
        x = self.encoder(x)
        x = self.decoder(x)
        return x

trainS8 = trainS8.values.astype(np.float32)
trainS8 = th.tensor(trainS8)
print("Forma de input_data:", trainS8.shape)
print("Tipo de dato de input_data:", trainS8.dtype)

autoencoder = Autoencoder()
with th.no_grad():
    trainS8_pred_SE = autoencoder(trainS8)

trainS8_nump = trainS8.detach().numpy()
trainS8_pred_SE = trainS8_pred_SE.detach().numpy()
plt.plot(trainS8_nump[0], label = 'Valor de la parte real de las impedancias de entrenamiento')
plt.plot(trainS8_pred_SE[0], label = 'Valor predecido de la parte real de las impedancias de entrenamiento')
plt.show()

"""## ENTRENAMIENTO DEL MODELO

Let's plot training and validation loss to see how the training went.
"""

# Debes tener un conjunto de datos de entrenamiento y un conjunto de datos de prueba
train_data = trainS8

autoencoder = Autoencoder()
optimizer = th.optim.Adam(autoencoder.parameters(), lr=0.001)
criterion = nn.MSELoss()
i=-1
epoch_v = np.zeros(20)
loss_v = np.zeros(20)
# Entrenar el autoencoder
for epoch in range(20):
    i = i+1
    for data in train_data:
        # Asegúrate de que tus datos de entrada tengan la forma correcta
        data = data.view(1, -1)
        optimizer.zero_grad()
        outputs = autoencoder(data)
        loss = criterion(outputs, data)
        loss.backward()
        optimizer.step()
        epoch_v[i] = epoch
        loss_v[i] = loss.item()

        print(f'Epoch:{epoch+1}, Loss:{loss.item():.4f}')

plt.plot(loss_v)

trainS8_pred = autoencoder (trainS8)
trainS8_rmse_loss = rmse(trainS8,trainS8_pred)

import matplotlib.pyplot as plt

train_data_np = trainS8.view(-1).detach().numpy()
trainS8_pred_np = trainS8_pred.view(-1).detach().numpy()

plt.figure(figsize=(10, 5))
plt.plot(train_data_np[0:7201], label='Original')
plt.plot(trainS8_pred_np[0:7201], label='Reconstructed')
plt.legend()
plt.show()

print(trainS8_rmse_loss)

print(trainS8)
print(trainS8_pred)

# Datos de prueba

testS8= testS8.values.astype(np.float32)
testS8 = th.tensor(testS8)
testS8_pred = autoencoder(testS8)

print(testS8)
print(testS8_pred)

testS8_rmse_loss = rmse(testS8,testS8_pred)
print(testS8_rmse_loss)

# Ahora puedes visualizar la entrada y la salida
import matplotlib.pyplot as plt

test_data_np = testS8.view(-1).detach().numpy()
testS8_pred_np = testS8_pred.view(-1).detach().numpy()

plt.figure(figsize=(10, 5))
plt.plot(test_data_np[0:7201], label='Original')
plt.plot(testS8_pred_np[0:7201], label='Reconstructed')
plt.legend()
plt.show()

"""## DETECCIÓN DE ANOMALÍAS

We will detect anomalies by determining how well our model can reconstruct
the input data.


1.   Find RMSE loss on training samples.
2.   Find max RMSE loss value. This is the worst our model has performed trying
to reconstruct a sample. We will make this the `threshold` for anomaly
detection.
3.   If the reconstruction loss for a sample is greater than this `threshold`
value then we can infer that the model is seeing a pattern that it isn't
familiar with. We will label this sample as an `anomaly`.

###PASO DE CARGA 1
"""

testS8_pc1.shape

testS8_pc1_pred = autoencoder(testS8_pc1)
testS8_pc1_pred.shape

testS8_pc1_np = testS8_pc1.detach().numpy()
testS8_pc1_pred_np = testS8_pc1_pred.detach().numpy()
plt.plot(testS8_pc1_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc1_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

testS8_pc1_rmse_loss = rmse(testS8_pc1_pred,testS8_pc1)

print(testS8_pc1_rmse_loss)

# plt.scatter(1, trainS8_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS8_rmse_loss, label='Validación')
# plt.scatter(1, testS8_pc1_rmse_loss, label='Paso de carga 1')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""## PASO DE CARGA 1 CON VALORES ATÍPICOS"""

import random

testS8_pc1_n2_2 = testS8_pc1_n2.to_numpy() if isinstance(testS8_pc1_n2, pd.DataFrame) else testS8_pc1_n2
testS8_pc1_VA = testS8_pc1_n2_2.copy()
slice_to_modify = testS8_pc1_VA[:, 200:400]
random_values = np.random.randint(2, size=slice_to_modify.shape)
testS8_pc1_VA[:, 200:400] = random_values
print(testS8_pc1_VA)
plt.plot(testS8_pc1_VA.ravel()[0:7201], label='Paso de carga modificado')
plt.show()
print(testS8_pc1_VA.shape)

testS8_pc1_VA = th.tensor(testS8_pc1_VA)
testS8_pc1_VA = testS8_pc1_VA.float()
testS8_pc1_VA.shape

testS8_pc1_VA_pred = autoencoder(testS8_pc1_VA)

testS8_pc1_VA_np = testS8_pc1_VA.detach().numpy()
testS8_pc1_VA_pred_np = testS8_pc1_VA_pred.detach().numpy()
plt.plot(testS8_pc1_VA_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc1_VA_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

"""###PASO DE CARGA 2"""

testS8_pc2_pred = autoencoder(testS8_pc2)
testS8_pc2_rmse_loss = rmse(testS8_pc2_pred,testS8_pc2)

testS8_pc2_np = testS8_pc2.detach().numpy()
testS8_pc2_pred_np = testS8_pc2_pred.detach().numpy()
plt.plot(testS8_pc2_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc2_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

# plt.scatter(1, trainS8_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS8_rmse_loss, label='Validación')
# plt.scatter(1, testS8_pc2_rmse_loss, label='Paso de carga 2')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""###PASO DE CARGA 3

"""

testS8_pc3_pred = autoencoder(testS8_pc3)
testS8_pc3_rmse_loss = rmse(testS8_pc3_pred,testS8_pc3)

testS8_pc3_np = testS8_pc3.detach().numpy()
testS8_pc3_pred_np = testS8_pc3_pred.detach().numpy()
plt.plot(testS8_pc3_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc3_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

# plt.scatter(1, trainS8_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS8_rmse_loss, label='Validación')
# plt.scatter(1, testS8_pc3_rmse_loss, label='Paso de carga 3')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""###PASO DE CARGA 4"""

testS8_pc4_pred = autoencoder(testS8_pc4)
testS8_pc4_rmse_loss = rmse(testS8_pc4_pred,testS8_pc4)

testS8_pc4_np = testS8_pc4.detach().numpy()
testS8_pc4_pred_np = testS8_pc4_pred.detach().numpy()
plt.plot(testS8_pc4_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc4_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

# plt.scatter(1, trainS8_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS8_rmse_loss, label='Validación')
# plt.scatter(1, testS8_pc4_rmse_loss, label='Paso de carga 4')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""###PASO DE CARGA 5"""

testS8_pc5_pred = autoencoder(testS8_pc5)
testS8_pc5_rmse_loss = rmse(testS8_pc5_pred,testS8_pc5)

testS8_pc5_np = testS8_pc5.detach().numpy()
testS8_pc5_pred_np = testS8_pc5_pred.detach().numpy()
plt.plot(testS8_pc5_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc5_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

# plt.scatter(1, trainS8_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS8_rmse_loss, label='Validación')
# plt.scatter(1, testS8_pc5_rmse_loss, label='Paso de carga 5')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""

###PASO DE CARGA 6"""

testS8_pc6_pred = autoencoder(testS8_pc6)
testS8_pc6_rmse_loss = rmse(testS8_pc6_pred,testS8_pc6)

testS8_pc6_np = testS8_pc6.detach().numpy()
testS8_pc6_pred_np = testS8_pc6_pred.detach().numpy()
plt.plot(testS8_pc6_np[0], label='Paso de carga modificado')
plt.plot(testS8_pc6_pred_np[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

# plt.scatter(1, trainS8_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS8_rmse_loss, label='Validación')
# plt.scatter(1, testS8_pc6_rmse_loss, label='Paso de carga 6')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

plt.bar(-1, trainS8_rmse_loss, label='Training')
plt.bar(0, testS8_rmse_loss, label='Validation')
plt.bar(1, testS8_pc1_rmse_loss, label='Paso de carga 1')
plt.bar(2, testS8_pc2_rmse_loss, label='Paso de carga 2')
plt.bar(3, testS8_pc3_rmse_loss, label='Paso de carga 3')
plt.bar(4, testS8_pc4_rmse_loss, label='Paso de carga 4')
plt.bar(5, testS8_pc5_rmse_loss, label='Paso de carga 5')
plt.xlabel('Load Steps')
plt.ylabel('RMSE')
plt.title('RMSE for Different Load Steps')
plt.legend()
plt.show()