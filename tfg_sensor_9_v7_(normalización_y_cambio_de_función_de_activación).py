# -*- coding: utf-8 -*-
"""TFG SENSOR 9 v7 (normalización y cambio de función de activación)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qLOMdbVUzGW9Cbf_iLxYhwCIzpedO6lt

#AUTOENCODER PARA DETECTAR ANOMALÍAS EN ESTRUCTURAS

## LIBRERÍAS
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, regularizers
from matplotlib import pyplot as plt
from tensorflow.keras.layers import Conv1D, Conv1DTranspose, Dense, Flatten, Reshape, Dropout
from tensorflow.keras.models import Sequential

from sklearn.metrics import mean_squared_error
def rmse(y,yprime):
    return np.sqrt(mean_squared_error(y,yprime))

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')

! ls
# %cd /content/drive/MyDrive/Colab\ Notebooks/Sensor9
! ls
! pwd

"""##**SENSOR 9**

"""

sensor9_s = pd.read_excel("PROBETA1_BASELINE_VEDIT_sensor9_AUTOENCODER.xlsx")
print(sensor9_s.head())

min_reference_b = sensor9_s.min().min()
max_reference_b = sensor9_s.max().max()
min = min_reference_b
max = max_reference_b
print(max)
print(min)

"""

## DETERMINACIÓN DE LA REFERRENCIA PARA LA NORMALIZACIÓN DE DATOS
"""

testS9_pc1_s = pd.read_excel("PROBETA1_PASO_CARGA_1_sensor9_AUTOENCODER.xlsx")
min_reference_1 = testS9_pc1_s.min().min()
max_reference_1 = testS9_pc1_s.max().max()
print(max_reference_1)
print(min_reference_1)
if max_reference_1 > max :
  max = max_reference_1
  min = min_reference_1
print(max)
print(min)

testS9_pc2_s = pd.read_excel("PROBETA1_PASO_CARGA_2_sensor9_AUTOENCODER.xlsx")
min_reference_2 = testS9_pc2_s.min().min()
max_reference_2 = testS9_pc2_s.max().max()
print(max_reference_2)
print(min_reference_2)
if max_reference_2 > max :
  max = max_reference_2
  min = min_reference_2
print(max)
print(min)

testS9_pc3_s = pd.read_excel("PROBETA1_PASO_CARGA_3_sensor9_AUTOENCODER.xlsx")
min_reference_3 = testS9_pc3_s.min().min()
max_reference_3 = testS9_pc3_s.max().max()
print(max_reference_3)
print(min_reference_3)
if max_reference_3 > max :
  max = max_reference_3
  min = min_reference_3
print(max)
print(min)

testS9_pc4_s = pd.read_excel("PROBETA1_PASO_CARGA_4_sensor9_AUTOENCODER.xlsx")
min_reference_4 = testS9_pc4_s.min().min()
max_reference_4 = testS9_pc4_s.max().max()
print(max_reference_4)
print(min_reference_4)
if max_reference_4 > max :
  max = max_reference_4
  min = min_reference_4
print(max)
print(min)

testS9_pc5_s = pd.read_excel("PROBETA1_PASO_CARGA_5_sensor9_AUTOENCODER.xlsx")
min_reference_5 = testS9_pc5_s.min().min()
max_reference_5 = testS9_pc5_s.max().max()
print(max_reference_5)
print(min_reference_5)
if max_reference_5 > max :
  max = max_reference_5
  min = min_reference_5
print(max)
print(min)

testS9_pc6_s = pd.read_excel("PROBETA1_PASO_CARGA_6_VIGA_ROTA_sensor9_AUTOENCODER.xlsx")
min_reference_6 = testS9_pc6_s.min().min()
max_reference_6 = testS9_pc6_s.max().max()
print(max_reference_6)
print(min_reference_6)
if max_reference_6 > max :
  max = max_reference_6
  min = min_reference_6
print(max)
print(min)

"""## GRÁFICA DE LOS DATOS"""

plt.plot(sensor9_s['P_  1'], label = 'Baseline')
plt.plot(testS9_pc1_s['PP1_1'], label = 'Paso de carga 1')
plt.plot(testS9_pc2_s['PP2_1'], label = 'Paso de carga 2')
plt.plot(testS9_pc3_s['PP3_1'], label = 'Paso de carga 3')
plt.plot(testS9_pc4_s['PP4_1'], label = 'Paso de carga 4')
plt.plot(testS9_pc5_s['PP5_1'], label = 'Paso de carga 5')
plt.title('Impedances for Different Load Steps not including the state of rupture')
plt.legend()
plt.show()

"""## NORMALIZACIÓN DE LOS DATOS"""

sensor9 = (sensor9_s - min) / (max-min)

print(sensor9.head())

testS9_pc1_n = (testS9_pc1_s - min) / (max-min)
testS9_pc1_n2 = np.transpose(testS9_pc1_n)
testS9_pc1 = testS9_pc1_n2.values.reshape((testS9_pc1_n2.shape[0], testS9_pc1_n2.shape[1], 1))
print(testS9_pc1)
print(testS9_pc1.shape)

testS9_pc2_n = (testS9_pc2_s - min) / (max-min)
testS9_pc2_n2 = np.transpose(testS9_pc2_n)
testS9_pc2 = testS9_pc2_n2.values.reshape((testS9_pc2_n2.shape[0], testS9_pc2_n2.shape[1], 1))
print(testS9_pc2)
print(testS9_pc2.shape)

testS9_pc3_n = (testS9_pc3_s - min) / (max-min)
testS9_pc3_n2 = np.transpose(testS9_pc3_n)
testS9_pc3 = testS9_pc3_n2.values.reshape((testS9_pc3_n2.shape[0], testS9_pc3_n2.shape[1], 1))
print(testS9_pc3)
print(testS9_pc3.shape)

testS9_pc4_n = (testS9_pc4_s - min) / (max-min)
testS9_pc4_n2 = np.transpose(testS9_pc4_n)
testS9_pc4 = testS9_pc4_n2.values.reshape((testS9_pc4_n2.shape[0], testS9_pc4_n2.shape[1], 1))
print(testS9_pc4)
print(testS9_pc4.shape)

testS9_pc5_n = (testS9_pc5_s - min) / (max-min)
testS9_pc5_n2 = np.transpose(testS9_pc5_n)
testS9_pc5 = testS9_pc5_n2.values.reshape((testS9_pc5_n2.shape[0], testS9_pc5_n2.shape[1], 1))
print(testS9_pc5)
print(testS9_pc5.shape)

testS9_pc6_n = (testS9_pc6_s - min) / (max-min)
testS9_pc6_n2 = np.transpose(testS9_pc6_n)
testS9_pc6 = testS9_pc6_n2.values.reshape((testS9_pc6_n2.shape[0], testS9_pc6_n2.shape[1], 1))
print(testS9_pc6)
print(testS9_pc6.shape)

plt.plot(sensor9['P_  1'], label = 'Baseline')
plt.plot(testS9_pc1_n['PP1_1'], label = 'Paso de carga 1')
plt.plot(testS9_pc2_n['PP2_1'], label = 'Paso de carga 2')
plt.plot(testS9_pc3_n['PP3_1'], label = 'Paso de carga 3')
plt.plot(testS9_pc4_n['PP4_1'], label = 'Paso de carga 4')
plt.plot(testS9_pc5_n['PP5_1'], label = 'Paso de carga 5')
plt.title('Impedances normalized for Different Load Steps not including the state of rupture')
plt.legend()
plt.show()

"""## CREACIÓN DE LOS GRUPOS APRENDIZAJE Y TEST




"""

sensor9_t = np.transpose(sensor9)
print(sensor9_t.head())

from sklearn.model_selection import train_test_split
trainS9,testS9 = train_test_split(sensor9_t,train_size=0.75,random_state=111)
print(trainS9)

"""## PREPARACIÓN DATOS DE ENTRENAMIENTO


"""

trainS9 = trainS9.values.reshape((trainS9.shape[0], trainS9.shape[1], 1))
inputS9_shape = trainS9.shape[1:]
print(inputS9_shape)

trainS9.shape

trainS9.shape[0:2]

"""## RED NEURONAL

We will build a convolutional reconstruction autoencoder model. The model will
take input of shape `(batch_size, sequence_length, num_features)` and return
output of the same shape. In this case, `sequence_length` is 288 and
`num_features` is 1.
"""

modelS9 = Sequential()
modelS9.add(Conv1D(filters=64, kernel_size=3, activation='PReLU', padding='same',  kernel_regularizer=regularizers.l2(0.5), input_shape=inputS9_shape))
modelS9.add(Conv1D(filters=64, kernel_size=3, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1D(filters=32, kernel_size=3, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1D(filters=16, kernel_size=3, activation='PReLU', padding='same', kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1D(filters=8, kernel_size=3, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))

modelS9.add(Conv1DTranspose(filters=8, kernel_size=3, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1DTranspose(filters=16, kernel_size=5, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1DTranspose(filters=32, kernel_size=5, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1DTranspose(filters=64, kernel_size=5, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))
modelS9.add(Conv1DTranspose(filters=64, kernel_size=10, activation='PReLU', padding='same',kernel_regularizer=regularizers.l2(0.5)))

modelS9.add(Conv1D(filters=inputS9_shape[-1], kernel_size=3, activation='linear', padding='same'))

# Compilar el modelo
modelS9.compile(optimizer='adam', loss='mean_squared_error', metrics=['RootMeanSquaredError'])

trainS9_pred_SE = modelS9.predict(trainS9)
plt.plot(trainS9[0], label = 'Valor de la parte real de las impedancias de entrenamiento')
plt.plot(trainS9_pred_SE[0], label = 'Valor predecido de la parte real de las impedancias de entrenamiento')
plt.show()

"""## ENTRENAMIENTO DEL MODELO



"""

callback = tf.keras.callbacks.EarlyStopping(monitor = 'val_loss', patience = 5)
historyS9 = modelS9.fit(trainS9, trainS9, epochs=45, batch_size=5, validation_data=(testS9, testS9), callbacks = [callback])

"""Let's plot training and validation loss to see how the training went."""

plt.plot(historyS9.history["loss"], label="Training Loss")
plt.plot(historyS9.history["val_loss"], label="Validation Loss")
plt.legend()
plt.show()

optimizer = modelS9.optimizer
learning_rate = optimizer.learning_rate.numpy()
print("Tasa de aprendizaje:", learning_rate)

"""## DETECCIÓN DE ANOMALÍAS

We will detect anomalies by determining how well our model can reconstruct
the input data.


1.   Find RMSE loss on training samples.
2.   Find max RMSE loss value. This is the worst our model has performed trying
to reconstruct a sample. We will make this the `threshold` for anomaly
detection.
3.   If the reconstruction loss for a sample is greater than this `threshold`
value then we can infer that the model is seeing a pattern that it isn't
familiar with. We will label this sample as an `anomaly`.

"""

# Get train RMSE loss.
trainS9_pred = modelS9.predict(trainS9)
trainS9_pred2 = trainS9_pred.reshape((trainS9_pred.shape[0], trainS9_pred.shape[1]))
trainS9_2 = trainS9.reshape((trainS9.shape[0], trainS9.shape[1]))

trainS9_rmse_loss = rmse(trainS9_pred2,trainS9_2)

# plt.hist(trainS9_rmse_loss, bins=50)
# plt.xlabel("Train RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Get reconstruction loss threshold.
# thresholdS9 = np.max(trainS9_rmse_loss)
# print("Reconstruction error threshold: ", thresholdS9)

"""### Compare recontruction

Just for fun, let's see how our model has recontructed the first sample.
This is the 288 timesteps from day 1 of our training dataset.
"""

# Checking how the first sequence is learnt
plt.plot(trainS9[0])
plt.plot(trainS9_pred[0])
plt.show()

"""### Prepare test data"""

# fig, ax = plt.subplots()
# testS9.plot(legend=False, ax=ax)
# plt.show()
testS9 = testS9.values.reshape((testS9.shape[0], testS9.shape[1], 1))
# Get test RMSE loss.

testS9_pred = modelS9.predict(testS9)
testS9_pred2 =  testS9_pred.reshape((testS9_pred.shape[0], testS9_pred.shape[1]))
testS9_2 =  testS9.reshape((testS9.shape[0], testS9.shape[1]))
testS9_rmse_loss = rmse(testS9_pred2,testS9_2)


# plt.hist(testS9_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9 = testS9_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9))
# print("Indices of anomaly samples: ", np.where(anomaliesS9))

plt.plot(testS9[0])
plt.plot(testS9_pred[0])
plt.show()

print(testS9_rmse_loss)

"""###PASO DE CARGA 1


"""

testS9_pc1_pred = modelS9.predict(testS9_pc1)
testS9_pc1_pred.shape

plt.plot(testS9_pc1[0], label='Original')
plt.plot(testS9_pc1_pred[0], label='Reconstructed')
plt.show()

testS9_pc1_pred2 =  testS9_pc1_pred.reshape((testS9_pc1_pred.shape[0], testS9_pc1_pred.shape[1]))
testS9_pc1_2 =  testS9_pc1.reshape((testS9_pc1.shape[0], testS9_pc1.shape[1]))
testS9_pc1_rmse_loss = rmse(testS9_pc1_pred2,testS9_pc1_2)



# plt.hist(testS9_pc1_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9_pc1 = testS9_pc1_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9_pc1))
# print("Indices of anomaly samples: ", np.where(anomaliesS9_pc1))

print(testS9_pc1_rmse_loss)

# plt.scatter(1, trainS9_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS9_rmse_loss, label='Validación')
# plt.scatter(1, testS9_pc1_rmse_loss, label='Paso de carga 1')
# plt.axhline(y=thresholdS9, color='r', linestyle='--')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""## PASO DE CARGA 1 CON VALORES ATÍPICOS"""

import random

testS9_pc1_n2_2 = testS9_pc1_n2.to_numpy() if isinstance(testS9_pc1_n2, pd.DataFrame) else testS9_pc1_n2
testS9_pc1_VA = testS9_pc1_n2_2.copy()
slice_to_modify = testS9_pc1_VA[:, 200:400]
random_values = np.random.randint(2, size=slice_to_modify.shape)
testS9_pc1_VA[:, 200:400] = random_values
print(testS9_pc1_VA)
plt.plot(testS9_pc1_VA.ravel()[0:7201], label='Paso de carga modificado')
plt.show()
print(testS9_pc1_VA.shape)

testS9_pc1_VA = testS9_pc1_VA.reshape((testS9_pc1_VA.shape[0], testS9_pc1_VA.shape[1], 1))
testS9_pc1_VA_pred = modelS9.predict(testS9_pc1_VA)
testS9_pc1_VA_pred.shape

plt.plot(testS9_pc1_VA[0], label='Paso de carga modificado')
plt.plot(testS9_pc1_VA_pred[0], label='Predicción del paso de carga modificado')
plt.legend()
plt.show()

"""###PASO DE CARGA 2"""

testS9_pc2_pred = modelS9.predict(testS9_pc2)
testS9_pc2_pred2 =  testS9_pc2_pred.reshape((testS9_pc2_pred.shape[0], testS9_pc2_pred.shape[1]))
testS9_pc2_2 =  testS9_pc2.reshape((testS9_pc2.shape[0], testS9_pc2.shape[1]))
testS9_pc2_rmse_loss = rmse(testS9_pc2_pred2,testS9_pc2_2)



# plt.hist(testS9_pc2_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9_pc2 = testS9_pc2_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9_pc2))
# print("Indices of anomaly samples: ", np.where(anomaliesS9_pc2))

plt.plot(testS9_pc2[0], label='Original')
plt.plot(testS9_pc2_pred[0], label='Reconstructed')
plt.show()

# plt.scatter(1, trainS9_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS9_rmse_loss, label='Validación')
# plt.scatter(1, testS9_pc2_rmse_loss, label='Paso de carga 2')
# plt.axhline(y=thresholdS9, color='r', linestyle='--')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""###PASO DE CARGA 3

"""

testS9_pc3_pred = modelS9.predict(testS9_pc3)
testS9_pc3_pred2 =  testS9_pc3_pred.reshape((testS9_pc3_pred.shape[0], testS9_pc3_pred.shape[1]))
testS9_pc3_2 =  testS9_pc3.reshape((testS9_pc3.shape[0], testS9_pc3.shape[1]))
testS9_pc3_rmse_loss = rmse(testS9_pc3_pred2, testS9_pc3_2)



# plt.hist(testS9_pc3_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9_pc3 = testS9_pc3_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9_pc3))
# print("Indices of anomaly samples: ", np.where(anomaliesS9_pc3))

plt.plot(testS9_pc3[0], label='Original')
plt.plot(testS9_pc3_pred[0], label='Reconstructed')
plt.show()

# plt.scatter(1, trainS9_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS9_rmse_loss, label='Validación')
# plt.scatter(1, testS9_pc3_rmse_loss, label='Paso de carga 3')
# plt.axhline(y=thresholdS9, color='r', linestyle='--')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""###PASO DE CARGA 4"""

testS9_pc4_pred = modelS9.predict(testS9_pc4)
testS9_pc4_pred2 =  testS9_pc4_pred.reshape((testS9_pc4_pred.shape[0], testS9_pc4_pred.shape[1]))
testS9_pc4_2 =  testS9_pc4.reshape((testS9_pc4.shape[0], testS9_pc4.shape[1]))
testS9_pc4_rmse_loss = rmse(testS9_pc4_pred2, testS9_pc4_2)



# plt.hist(testS9_pc4_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9_pc4 = testS9_pc4_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9_pc4))
# print("Indices of anomaly samples: ", np.where(anomaliesS9_pc4))

plt.plot(testS9_pc4[0], label='Original')
plt.plot(testS9_pc4_pred[0], label='Reconstructed')
plt.show()

# plt.scatter(1, trainS9_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS9_rmse_loss, label='Validación')
# plt.scatter(1, testS9_pc4_rmse_loss, label='Paso de carga 4')
# plt.axhline(y=thresholdS9, color='r', linestyle='--')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""###PASO DE CARGA 5"""

testS9_pc5_pred = modelS9.predict(testS9_pc5)
testS9_pc5_pred2 =  testS9_pc5_pred.reshape((testS9_pc5_pred.shape[0], testS9_pc5_pred.shape[1]))
testS9_pc5_2 =  testS9_pc5.reshape((testS9_pc5.shape[0], testS9_pc5.shape[1]))
testS9_pc5_rmse_loss = rmse(testS9_pc5_pred2,testS9_pc5_2)



# plt.hist(testS9_pc5_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9_pc5 = testS9_pc5_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9_pc5))
# print("Indices of anomaly samples: ", np.where(anomaliesS9_pc5))

plt.plot(testS9_pc5[0], label='Original')
plt.plot(testS9_pc5_pred[0], label='Reconstructed')
plt.show()

# plt.scatter(1, trainS9_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS9_rmse_loss, label='Validación')
# plt.scatter(1, testS9_pc5_rmse_loss, label='Paso de carga 5')
# plt.axhline(y=thresholdS9, color='r', linestyle='--')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

"""

###PASO DE CARGA 6"""

testS9_pc6_pred = modelS9.predict(testS9_pc6)
testS9_pc6_pred2 =  testS9_pc6_pred.reshape((testS9_pc6_pred.shape[0], testS9_pc6_pred.shape[1]))
testS9_pc6_2 =  testS9_pc6.reshape((testS9_pc6.shape[0], testS9_pc6.shape[1]))
testS9_pc6_rmse_loss = rmse(testS9_pc6_pred2, testS9_pc6_2)


# plt.hist(testS9_pc6_rmse_loss, bins=50)
# plt.xlabel("test RMSE loss")
# plt.ylabel("No of samples")
# plt.show()

# # Detect all the samples which are anomalies.
# anomaliesS9_pc6 = testS9_pc6_rmse_loss > thresholdS9
# print("Number of anomaly samples: ", np.sum(anomaliesS9_pc6))
# print("Indices of anomaly samples: ", np.where(anomaliesS9_pc6))

plt.plot(testS9_pc6[0], label='Original')
plt.plot(testS9_pc6_pred[0], label='Reconstructed')
plt.show()

# plt.scatter(1, trainS9_rmse_loss, label='Entrenamiento')
# plt.scatter(1, testS9_rmse_loss, label='Validación')
# plt.scatter(1, testS9_pc6_rmse_loss, label='Paso de carga 6')
# plt.axhline(y=thresholdS9, color='r', linestyle='--')
# plt.xlabel('Ensayos')
# plt.ylabel('RMSE')
# plt.legend()
# plt.show()

plt.bar(-1, trainS9_rmse_loss, label='Training')
plt.bar(0, testS9_rmse_loss, label='Validation')
plt.bar(1, testS9_pc1_rmse_loss, label='Paso de carga 1')
plt.bar(2, testS9_pc2_rmse_loss, label='Paso de carga 2')
plt.bar(3, testS9_pc3_rmse_loss, label='Paso de carga 3')
plt.bar(4, testS9_pc4_rmse_loss, label='Paso de carga 4')
plt.bar(5, testS9_pc5_rmse_loss, label='Paso de carga 5')
plt.xlabel('Load Steps')
plt.ylabel('RMSE')
plt.title('RMSE for Different Load Steps')
plt.legend()
plt.show()

plt.bar(-1, trainS9_rmse_loss, label='Training')
plt.bar(0, testS9_rmse_loss, label='Validation')
plt.bar(1, testS9_pc1_rmse_loss, label='Paso de carga 1')
plt.bar(2, testS9_pc2_rmse_loss, label='Paso de carga 2')
plt.bar(3, testS9_pc3_rmse_loss, label='Paso de carga 3')
plt.bar(4, testS9_pc4_rmse_loss, label='Paso de carga 4')
plt.bar(5, testS9_pc5_rmse_loss, label='Paso de carga 5')
plt.bar(6, testS9_pc6_rmse_loss, label='Paso de carga 6')
plt.xlabel('Load Steps')
plt.ylabel('RMSE')
plt.title('RMSE for Different Load Steps')
plt.legend()
plt.show()